<html>

<head>
  <title>test</title>
  <style>
    body {
      background-color: #ccc;
      background-image:
        linear-gradient(45deg, #666 25%, transparent 25%),
        linear-gradient(135deg, #666 25%, transparent 25%),
        linear-gradient(45deg, transparent 75%, #666 75%),
        linear-gradient(135deg, transparent 75%, #666 75%);
      background-size: 10px 10px;
      background-position: 0 0, 5px 0, 5px -5px, 0 5px;
    }

    svg.context-menu {
      position: absolute;
      top: 0;
      left: 0;
      width: 240px;
      height: 240px;
      margin-left: -120px;
      margin-top: -120px;
      user-select: none;
      font-family: sans-serif;
      clip-path: circle(120px);
      clip-path: stroke-box;
      shape-rendering: geometricPrecision;
      color-rendering: optimizeQuality;
      color-interpolation: sRGB;
    }

    svg.context-menu.animated {
      transition: visibility 500ms,
        left 40ms ease-out,
        top 40ms ease-out;
    }

    svg.context-menu.animated .menuGroup {
      transition: transform 60ms ease-in;
    }

    svg.context-menu circle {
      stroke: black;
      stroke-width: 0.0025;
    }

    svg.context-menu.animated circle {
      transition: fill 60ms linear;
    }

    svg.context-menu .menuEntry {
      cursor: pointer;
    }

    svg.context-menu .menuEntry .hoverScaleGroup {
      transform: scale(1.00);
    }

    svg.context-menu.animated .menuEntry .hoverScaleGroup {
      transition: transform 20ms ease-out;
    }

    svg.context-menu .menuEntry:hover .hoverScaleGroup {
      transform: scale(1.05);
    }

    svg.context-menu .menuEntry .introScaleGroup {
      transform: scale(0);
    }

    svg.context-menu.animated .menuEntry .introScaleGroup {
      transition: transform 60ms linear;
    }

    svg.context-menu .menuEntry .introScaleGroup.show {
      transform: scale(1);
    }

    svg.context-menu .menuEntry path {
      fill: lightgray;
      stroke: black;
      stroke-width: 0.002;
    }

    svg.context-menu .menuEntry.slider {
      cursor: initial;
    }

    svg.context-menu .menuEntry.slider .sliderPointer {
      cursor: grab;
      pointer-events: bounding-box;
    }
    
    svg.context-menu .menuEntry.slider.selecting .sliderPointer {
      cursor: grabbing;
    }

    svg.context-menu .menuEntry.slider .sliderPointer line {
      stroke: black;
      stroke-width: 0.001;
    }

    svg.context-menu .menuEntry.slider .sliderPointer circle {
      fill: none;
      stroke-width: 0.02;
    }

    svg.context-menu.animated .menuEntry path {
      transition: fill 80ms;
    }

    svg.context-menu .menuEntry:hover path,
    svg.context-menu .menuEntry.menuEntry.slider.selecting path {
      fill: cornflowerblue;
    }

    svg.context-menu .menuEntry text {
      font-size: 0.08;
      font-weight: 500;
      fill: black;
      dominant-baseline: middle;
    }

    svg.context-menu.animated .menuEntry text {
      transition: font-weight 100ms linear, fill 80ms ease;
    }

    svg.context-menu .menuEntry:hover text,
    svg.context-menu .menuEntry.menuEntry.slider.selecting text {
      fill: white;
      font-weight: 600;
    }
  </style>
</head>

<body>
  <svg viewBox="0 0 1 1" id="contextMenuContainer">
  </svg>
  <script>
    "Strict mode";

    function polarToCartesian(centerX, centerY, radius, angleInDegrees) {
      var angleInRadians = (angleInDegrees - 90) * Math.PI / 180.0;

      return {
        x: centerX + (radius * Math.cos(angleInRadians)),
        y: centerY + (radius * Math.sin(angleInRadians))
      };
    }

    class CircleMenu {
      constructor(svgContainer, entries, options = { animated: false }) {
        this.svgContainer = svgContainer;
        svgContainer.setAttribute('vector-effect', 'non-scaling-stroke');
        svgContainer.classList.add('context-menu');
        this.svgNS = this.svgContainer.namespaceURI;
        this.entries = entries;
        this.entryMap = {};
        this.options = options;
        this.color = {
          'format': 'RGB',
          'data': {
            'r': 0,
            'g': 0,
            'b': 0
          },
          'alpha': 1
        };
        this.radii = { inner: 0.1, outer: 0.5, center: 0.3 };

        this.svgContainer.style.visibility = 'hidden';

        this.menuContainer = this.createSVGElement('g');
        this.addSVGTransform(this.menuContainer, tf => tf.setTranslate(0.5, 0.5));
        this.addSVGTransform(this.menuContainer, tf => (this.scaleTransformation = tf));
        console.log(this.scaleTransformation);
        this.menuContainer.classList.add('menuGroup');
        svgContainer.appendChild(this.menuContainer);

        this.colorPreview = this.createSVGElement('circle');
        this.colorPreview.setAttribute('r', this.radii.outer);
        this.addSVGTransform(this.colorPreview, tf => tf.setScale(1.05, 1.05));
        this.colorPreview.addEventListener('click', () => this.close());
        this.menuContainer.appendChild(this.colorPreview);
        this.updateColor();

        this.menuMainElements = this.createSVGElement('g');
        this.menuMainElements.classList.add('menuMainElementGroup');
        this.menuContainer.appendChild(this.menuMainElements);

        const sectionAlphaSize = 360 / this.entries.length;
        this.entries.forEach((menuEntry, index) => {
          this.entryMap[menuEntry.name] = menuEntry;
          menuEntry.index = index;
          menuEntry.alphaSize = sectionAlphaSize;
          menuEntry.alphaStart = index * sectionAlphaSize;
          menuEntry.alphaEnd = menuEntry.alphaStart + sectionAlphaSize;
          menuEntry.radii = this.radii;
          this.createMenuEntry(menuEntry);
        });

        this.close();
      }

      createSVGElement(tagName) {
        return document.createElementNS(this.svgNS, tagName);
      }
      addSVGTransform(element, transformationSetter) {
        const transform = this.svgContainer.createSVGTransform();
        transformationSetter(transform);
        element.transform.baseVal.appendItem(transform);
      }

      createMenuEntry(menuEntry) {
        const menuElementGroup = this.createSVGElement('g');
        menuElementGroup.classList.add('menuEntry');
        menuElementGroup.dataset.entry = menuEntry.name;
        menuEntry.element = menuElementGroup;
        this.addSVGTransform(menuElementGroup, tf => tf.setRotate(menuEntry.alphaStart, 0, 0));
        menuElementGroup.addEventListener('click', (evt) => {
          evt.menuEntry = menuEntry;
          evt.menu = this;
          menuEntry.eventHandler(evt);
        });
        this.menuMainElements.appendChild(menuElementGroup);

        const hoverScaleGroup = this.createSVGElement('g');
        hoverScaleGroup.classList.add('hoverScaleGroup');
        menuElementGroup.appendChild(hoverScaleGroup);
        
        const introScaleGroup = this.createSVGElement('g');
        introScaleGroup.classList.add('introScaleGroup');
        if (this.options.animated) {
        introScaleGroup.style.transitionDelay = 30 + (20 * menuEntry.index) + 'ms';
        }
        menuEntry.introScaleGroup = introScaleGroup;
        hoverScaleGroup.appendChild(introScaleGroup);

        const menuElementBG = this.createSVGElement('path');
        menuElementBG.id = menuEntry.name;
        menuElementBG.setAttribute('d', this.pathCircleSection(
          { x: 0, y: 0 }, menuEntry.radii,
          - menuEntry.alphaSize / 2,
          + menuEntry.alphaSize / 2
        ));
        introScaleGroup.appendChild(menuElementBG);

        const menuElementText = this.createSVGElement('text');
        menuElementText.textContent = menuEntry.name;
        introScaleGroup.appendChild(menuElementText);
        const textLength = menuElementText.getComputedTextLength();
        this.addSVGTransform(menuElementText, tf => tf.setRotate(-90, 0, 0));
        this.addSVGTransform(menuElementText, tf => tf.setTranslate(menuEntry.radii.center, 0));
        this.addSVGTransform(menuElementText, tf => tf.setTranslate(-textLength / 2, 0));
        if (menuEntry.alphaStart >= 180) {
          this.addSVGTransform(menuElementText, tf => tf.setRotate(180, textLength / 2, 0));
        }
      }

      registerAsContextMenu() {
        document.addEventListener('contextmenu', (evt) => {
          evt.preventDefault();
          this.openAt(evt.clientX, evt.clientY);
        });
        document.addEventListener('mousedown', (evt) => {
          if (this.isOpen() && !this.svgContainer.contains(evt.target)) {
            if(event.button != 2) {
              evt.preventDefault();
              this.close();
            }
          }
        });
        document.addEventListener('keyup', (evt) => {
          if (this.isOpen() && evt.key == 'Escape') {
            evt.preventDefault();
            this.close();
          }
        });
      }

      getMenuEntry(entryName) {
        return this.entryMap[entryName];
      }

      get currentColor() {
        return this.colorPreview.fill;
      }

      updateColor() {
        let colorString;
        switch (this.color.format) {
          case 'RGB':
            colorString = `rgba(${this.color.data.r * 255}, ${this.color.data.g * 255}, ${this.color.data.b * 255}, ${this.color.alpha})`;
            break;
        }
        console.log(colorString);
        this.colorPreview.setAttribute('fill', colorString);
      }

      setColorAlpha(alpha) {
        this.color.alpha = alpha;
        this.updateColor();
      }

      setColorRGB(r, g, b) {
        this.color.format = 'RGB';
        this.color.data = {
          'r': r,
          'g': g,
          'b': b
        };
        this.updateColor();
      }

      setColorRandom() {
        this.setColorRGB(Math.random(), Math.random(), Math.random());
      }

      setScale(scale) {
        this.scaleTransformation.setScale(scale, scale);
      }

      isOpen() {
        return this.svgContainer.style.visibility == 'visible';
      }

      openAt(x, y) {
        this.svgContainer.style.left = x;
        this.svgContainer.style.top = y;
        if(!this.isOpen()) {
          this.entries.forEach(entry => entry.introScaleGroup.classList.add('show'));
          this.setScale(0.95);
          this.svgContainer.style.visibility = 'visible';
        }
      }

      close() {
        this.svgContainer.style.visibility = 'hidden';
        this.setScale(0.0);
        this.entries.forEach(entry => entry.introScaleGroup.classList.remove('show'));
      }

      pathCircleSection(center, radii, startAngle, endAngle) {
        const startIn = polarToCartesian(center.x, center.y, radii.inner, endAngle);
        const startOut = polarToCartesian(center.x, center.y, radii.outer, endAngle);
        const endOut = polarToCartesian(center.x, center.y, radii.outer, startAngle);
        const endIn = polarToCartesian(center.x, center.y, radii.inner, startAngle);

        const largeArcFlag = (endAngle - startAngle <= 180) ? 0 : 1;

        const d = [
          'M', startIn.x, startIn.y,
          'L', startOut.x, startOut.y,
          'A', radii.outer, radii.outer, 0, largeArcFlag, 0, endOut.x, endOut.y,
          'L', endIn.x, endIn.y,
          'A', radii.inner, radii.inner, 0, largeArcFlag, 1, startIn.x, startIn.y,
        ];
        return d.join(' ');
      }
    }

    (window.contextMenu = new CircleMenu(
      document.getElementById('contextMenuContainer'),
      [
      {
        name: 'Alpha', eventHandler: (evt) => {
          evt.menu.setColorAlpha(Math.random());
        }
      },
      {
        name: 'RGB', eventHandler: (evt) => {
          evt.menu.setColorRGB(1, 0, 0);
        }
      },
      // { name: 'YCbCr', eventHandler: (evt) => console.log(evt.menuEntry) },
      { name: 'HSB', eventHandler: (evt) => console.log(evt.menuEntry) },
      { name: 'HSL', eventHandler: (evt) => console.log(evt.menuEntry) },
      { name: 'Recent', eventHandler: (evt) => console.log(evt.menuEntry) },
      { name: 'Saved', eventHandler: (evt) => console.log(evt.menuEntry) },
      {
        name: 'Random', eventHandler: (evt) => {
          evt.menu.setColorRandom();
        }
        }
      ],
      {
        animated: false
      }
    )).registerAsContextMenu();
  </script>
</body>

</html>